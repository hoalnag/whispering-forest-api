<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>whispering forest â€“ scene A</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- å­—ä½“ï¼šAmatic SC -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&display=swap"
    rel="stylesheet"
  />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: "Amatic SC", sans-serif;
      background: #000;          /* ğŸ”¥ çº¯é»‘èƒŒæ™¯ï¼Œä»¥åè¿™é‡Œå¯ä»¥æ¢æˆèƒŒæ™¯å›¾ */
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    main {
      width: min(90%, 900px);
      height: min(90vh, 600px);
      position: relative;

      /* âŒ å»æ‰ç›’å­æ„Ÿï¼šä¸è¦è¾¹æ¡†ã€ä¸è¦å…‰æ™•ã€ä¸è¦é˜´å½± */
      border-radius: 0;
      border: none;
      background: transparent;
      box-shadow: none;

      overflow: visible;
    }

    .scene-title {
      position: absolute;
      top: 1.2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.4rem;
      letter-spacing: 0.18em;
      opacity: 0.8;
      text-transform: uppercase;
      user-select: none;
    }

    /* ä¸‰ä¸ªåœ†å½¢ keyspot å®¹å™¨ */
    .spots-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .spots-grid {
      width: 100%;
      max-width: 720px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3rem;
      padding: 0 3rem;
      pointer-events: none;

      /* â­ å…³é”®ï¼šè®©æ¯ä¸ª spot åœ¨æ ¼å­é‡Œæ°´å¹³/å‚ç›´å±…ä¸­ï¼Œè¿™æ ·æ”¾å¤§çš„æ—¶å€™æ˜¯ centered çš„ */
      justify-items: center;
      align-items: center;
    }

    .spot {
      pointer-events: auto;
      cursor: pointer;

      /* æœ‰æ–‡å­—æ—¶çš„åŸºç¡€å¤§å°ï¼›å®é™…å¤§å°åœ¨ JS é‡ŒæŒ‰å†…å®¹åŠ¨æ€è°ƒæ•´ */
      width: 140px;
      height: 140px;
      max-width: 50vw;
      max-height: 50vw;

      border-radius: 50%;
      border: 1.5px solid rgba(255,255,255,0.8);
      background: rgba(0,0,0,0.45);  /* æ‰å¹³ */
      box-shadow: none;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      text-align: center;
      position: relative;

      transition:
        border-color 140ms ease,
        background 140ms ease,
        transform 120ms ease,
        width 180ms ease,
        height 180ms ease;
    }

    .spot:hover {
      border-color: rgba(255,255,255,1);
      background: rgba(255,255,255,0.05);
      transform: translateY(-2px);
    }

    /* ç©ºçŠ¶æ€æ—¶ï¼šå°åœ†åœˆ + ä¸­é—´ä¸€ç‚¹ */
    .spot::before {
      content: "";
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
      opacity: 0.7;
      transition: opacity 120ms ease;
    }

    /* æœ‰æ–‡å­—æ—¶å–æ¶ˆä¸­é—´å°ç‚¹ */
    .spot.has-text::before {
      opacity: 0;
    }

    .spot-text {
      font-size: 1.4rem;
      white-space: pre-wrap;
      word-break: break-word;
      max-width: 90%;
      line-height: 1.25;
      opacity: 0.95;
    }

    .spot-empty .spot-text {
      display: none; /* åªæ˜¾ç¤ºå°ç‚¹ */
    }

    .status-bar {
      position: absolute;
      bottom: 0.6rem;
      left: 0;
      right: 0;
      padding: 0 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1rem;
      opacity: 0.85;
      pointer-events: none;
      gap: 0.6rem;
    }

    .nav-hint {
      font-size: 0.95rem;
      opacity: 0.7;
    }

    .status-right {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    /* é€šç”¨æŒ‰é’® */
    .btn {
      border: 1px solid rgba(255,255,255,0.7);
      background: transparent;
      padding: 0.4rem 1.4rem;
      border-radius: 999px;
      color: #fff;
      cursor: pointer;
      font-family: "Amatic SC", sans-serif;
      font-size: 1.2rem;
      transition: background 140ms ease, color 140ms ease, border-color 140ms ease;
      pointer-events: auto;
    }

    .btn:hover:not(:disabled) {
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.95);
      color: rgba(255,255,255,0.85);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    /* å°å·çš„å¯¼èˆªæŒ‰é’®ï¼ˆâ—€ â–¶ï¼‰ */
    .btn-nav {
      padding: 0.1rem 0.7rem;
      font-size: 1.1rem;
    }

    /* ç¼–è¾‘ overlay */
    .editor-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .editor-overlay.visible {
      display: flex;
    }

    .editor-box {
      width: min(90%, 520px);
      background: #050505;
      padding: 1.2rem 1.6rem 1rem;
      border-radius: 1.2rem;
      border: 1px solid rgba(255,255,255,0.3);
      box-shadow: 0 0 32px rgba(0,0,0,0.9);
    }

    .editor-prompt {
      font-size: 1.4rem;
      margin-bottom: 0.6rem;
    }

    .editor-input {
      width: 100%;
      min-height: 90px;
      resize: vertical;
      background: #050505;
      border: 1px solid rgba(255,255,255,0.4);
      border-radius: 0.8rem;
      padding: 0.6rem 0.8rem;
      color: #fff;
      font-family: "Amatic SC", sans-serif;
      font-size: 1.4rem;
      outline: none;
    }

    .editor-input:focus {
      border-color: rgba(255,255,255,0.9);
    }

    .editor-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      margin-top: 0.8rem;
    }

    @media (max-width: 720px) {
      .spots-grid {
        grid-template-columns: 1fr;
        gap: 1.6rem;
        padding: 0 1.6rem;
      }
      .spot {
        width: 140px;
        height: 140px;
      }
      .scene-title {
        font-size: 1.1rem;
      }
      .status-bar {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>
  <main>
    <div class="scene-title">choose your memory</div>

    <div class="spots-layer">
      <div class="spots-grid">
        <div class="spot spot-empty" data-spot="1">
          <div class="spot-text"></div>
        </div>

        <div class="spot spot-empty" data-spot="2">
          <div class="spot-text"></div>
        </div>

        <div class="spot spot-empty" data-spot="3">
          <div class="spot-text"></div>
        </div>
      </div>
    </div>

    <div class="status-bar">
      <span id="entry-counter">your memory Â· click a circle to write</span>
      <div class="status-right">
        <!-- æ‰‹æœº/æ¡Œé¢éƒ½èƒ½ç‚¹çš„å·¦å³åˆ‡æ¢æŒ‰é’® -->
        <button class="btn btn-nav" id="prev-memory-btn" aria-label="previous memory">â—€</button>
        <button class="btn btn-nav" id="next-memory-btn" aria-label="next memory">â–¶</button>

        <span class="nav-hint">
          â† / â†’ browse others Â· 0 = back to your circles
        </span>
        <!-- ä¸€æ¬¡æ€§ä¿å­˜ä¸‰ä¸ª spot çš„æŒ‰é’® -->
        <button class="btn" id="save-all" disabled>save memory</button>
      </div>
    </div>
  </main>

  <!-- ç¼–è¾‘ overlay -->
  <div class="editor-overlay" id="editor-overlay">
    <div class="editor-box">
      <div class="editor-prompt" id="editor-prompt">
        who were you with last time you ate a burger?
      </div>
      <textarea id="editor-input" class="editor-input"></textarea>

      <div class="editor-buttons">
        <button class="btn" id="editor-cancel">cancel</button>
        <!-- è¿™é‡Œåªæ˜¯â€œç¡®å®šè¿™ä¸€æ ¼â€ï¼Œä¸ä¿å­˜åˆ° API -->
        <button class="btn" id="editor-save">ok</button>
      </div>
    </div>
  </div>

  <script>
    // ===== çŠ¶æ€ =====
    let currentIndex = -1;  // -1 = è‡ªå·±çš„ circles
    let allEntries = [];
    let editingSpot = null;

    const draft = {
      spot1: "",
      spot2: "",
      spot3: ""
    };

    const prompts = {
      1: "who were you with last time you ate a burger?",
      2: "what were you eating?",
      3: "what could you hear around you?"
    };

    const spots = Array.from(document.querySelectorAll(".spot"));
    const entryCounter = document.getElementById("entry-counter");

    const overlay = document.getElementById("editor-overlay");
    const editorPrompt = document.getElementById("editor-prompt");
    const editorInput = document.getElementById("editor-input");
    const btnCancel = document.getElementById("editor-cancel");
    const btnSpotOk = document.getElementById("editor-save");
    const btnSaveAll = document.getElementById("save-all");

    const btnPrev = document.getElementById("prev-memory-btn");
    const btnNext = document.getElementById("next-memory-btn");

    // ===== å°ºå¯¸ç›¸å…³ï¼šæ ¹æ®æ–‡å­—å¤šå°‘åŠ¨æ€è°ƒæ•´åœ†åœˆå¤§å° =====
    function resizeSpot(spot, text) {
      const emptySize = 70;   // ç©ºåœˆï¼šæ›´å°
      const baseSize = 120;   // æœ‰å°‘é‡æ–‡å­—æ—¶çš„åŸºç¡€å°ºå¯¸
      const maxSize = 220;    // æœ€å¤§å°ºå¯¸

      const value = (text || "").trim();
      let size;

      if (!value) {
        size = emptySize;
      } else {
        const len = value.length;
        size = baseSize + len * 2;
        if (size > maxSize) size = maxSize;
      }

      spot.style.width = size + "px";
      spot.style.height = size + "px";
    }

    // ===== render & æ•°æ®ç›¸å…³ =====
    function getCurrentEntry() {
      if (currentIndex < 0 || currentIndex >= allEntries.length) return null;
      return allEntries[currentIndex];
    }

    function allDraftFilled() {
      return (
        draft.spot1.trim().length > 0 &&
        draft.spot2.trim().length > 0 &&
        draft.spot3.trim().length > 0
      );
    }

    function renderDraft() {
      spots.forEach(spot => {
        const s = spot.dataset.spot;
        const key = "spot" + s;
        const value = (draft[key] || "").trim();
        const textEl = spot.querySelector(".spot-text");

        if (value) {
          spot.classList.remove("spot-empty");
          spot.classList.add("has-text");
          textEl.textContent = value;
        } else {
          spot.classList.add("spot-empty");
          spot.classList.remove("has-text");
          textEl.textContent = "";
        }

        resizeSpot(spot, value);
      });

      if (allEntries.length > 0) {
        entryCounter.textContent = `your memory Â· ${allEntries.length} others`;
      } else {
        entryCounter.textContent = "your memory Â· click a circle to write";
      }

      btnSaveAll.disabled = !allDraftFilled();
    }

    function renderCurrentEntry() {
      if (currentIndex === -1) {
        renderDraft();
        return;
      }

      const entry = getCurrentEntry();
      if (!entry) {
        currentIndex = -1;
        renderDraft();
        return;
      }

      spots.forEach(spot => {
        const s = spot.dataset.spot;
        const key = "spot" + s;
        const value = (entry[key] || "").trim();
        const textEl = spot.querySelector(".spot-text");

        if (value) {
          spot.classList.remove("spot-empty");
          spot.classList.add("has-text");
          textEl.textContent = value;
        } else {
          spot.classList.add("spot-empty");
          spot.classList.remove("has-text");
          textEl.textContent = "";
        }

        resizeSpot(spot, value);
      });

      entryCounter.textContent =
        `memory ${currentIndex + 1} / ${allEntries.length} Â· read only`;

      btnSaveAll.disabled = true;
    }

    async function loadAllEntriesFromAPI() {
      try {
        const resp = await fetch("/api/a-entries");
        if (!resp.ok) {
          console.error("load error HTTP", resp.status);
          return;
        }
        const data = await resp.json();
        if (Array.isArray(data)) {
          allEntries = data.sort(
            (a, b) => (a.createdAt || 0) - (b.createdAt || 0)
          );
        } else {
          allEntries = [];
        }
      } catch (err) {
        console.error("load entries error:", err);
      } finally {
        if (currentIndex === -1) {
          renderDraft();
        } else {
          renderCurrentEntry();
        }
      }
    }

    function openEditor(spotNumber) {
      editingSpot = spotNumber;
      const key = "spot" + spotNumber;

      editorPrompt.textContent = prompts[spotNumber] || "write something";
      editorInput.value = draft[key] || "";
      overlay.classList.add("visible");
      editorInput.focus();
      editorInput.select();
    }

    function closeEditor() {
      overlay.classList.remove("visible");
      editingSpot = null;
    }

    function confirmDraftSpot() {
      if (!editingSpot) return;
      const key = "spot" + editingSpot;
      draft[key] = editorInput.value.trim();
      closeEditor();
      currentIndex = -1;
      renderDraft();
    }

    async function saveFullDraftToAPI() {
      if (!allDraftFilled()) return;

      const payload = {
        spot1: draft.spot1,
        spot2: draft.spot2,
        spot3: draft.spot3,
        createdAt: Date.now()
      };

      try {
        btnSaveAll.disabled = true;
        btnSaveAll.textContent = "saving...";

        const resp = await fetch("/api/a-entry", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          console.error("save error HTTP", resp.status);
        } else {
          console.log("saved entry");
        }
      } catch (err) {
        console.error("save error:", err);
      } finally {
        btnSaveAll.textContent = "save memory";
        await loadAllEntriesFromAPI();
        currentIndex = -1;
        renderDraft();
      }
    }

    function moveMemory(direction) {
      const len = allEntries.length;
      if (len === 0) {
        if (currentIndex !== -1) {
          currentIndex = -1;
          renderDraft();
        }
        return;
      }

      const total = len + 1;
      let pos = currentIndex + 1;

      if (direction > 0) {
        pos = (pos + 1) % total;
      } else {
        pos = (pos - 1 + total) % total;
      }

      currentIndex = pos - 1;
      if (currentIndex === -1) {
        renderDraft();
      } else {
        renderCurrentEntry();
      }
    }

    // ===== äº‹ä»¶ç»‘å®š =====
    spots.forEach(spot => {
      spot.addEventListener("click", () => {
        if (currentIndex !== -1) return;
        const n = Number(spot.dataset.spot);
        openEditor(n);
      });
    });

    btnCancel.addEventListener("click", (e) => {
      e.preventDefault();
      closeEditor();
    });

    btnSpotOk.addEventListener("click", (e) => {
      e.preventDefault();
      confirmDraftSpot();
    });

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) closeEditor();
    });

    btnSaveAll.addEventListener("click", async (e) => {
      e.preventDefault();
      if (!allDraftFilled()) return;
      await saveFullDraftToAPI();
    });

    btnPrev.addEventListener("click", (e) => {
      e.preventDefault();
      moveMemory(-1);
    });

    btnNext.addEventListener("click", (e) => {
      e.preventDefault();
      moveMemory(1);
    });

    document.addEventListener("keydown", (e) => {
      if (overlay.classList.contains("visible")) {
        if (e.key === "Escape") {
          e.preventDefault();
          closeEditor();
        }
        return;
      }

      if (e.key === "ArrowRight") {
        e.preventDefault();
        moveMemory(1);
      } else if (e.key === "ArrowLeft") {
        e.preventDefault();
        moveMemory(-1);
      } else if (e.key === "0") {
        currentIndex = -1;
        renderDraft();
      }
    });

    // ===== åˆå§‹åŒ– =====
    renderDraft();
    loadAllEntriesFromAPI();
  </script>
</body>
</html>