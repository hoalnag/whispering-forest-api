<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>whispering forest – scene A</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- 字体：Amatic SC -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&display=swap"
    rel="stylesheet"
  />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: "Amatic SC", sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    main {
      width: min(90%, 900px);
      height: min(90vh, 600px);
      position: relative;
      border-radius: 1.4rem;
      border: 1px solid rgba(255,255,255,0.25);
      background: radial-gradient(circle at 50% 20%, rgba(255,255,255,0.08), transparent 60%);
      box-shadow: 0 0 40px rgba(0,0,0,0.9);
      overflow: hidden;
    }

    .scene-title {
      position: absolute;
      top: 1.2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.4rem;
      letter-spacing: 0.18em;
      opacity: 0.8;
      text-transform: uppercase;
      user-select: none;
    }

    /* 三个圆形 keyspot 容器 */
    .spots-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .spots-grid {
      width: 100%;
      max-width: 720px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3rem;
      padding: 0 3rem;
      pointer-events: none;
    }

    .spot {
      pointer-events: auto;
      cursor: pointer;
      width: 160px;
      height: 160px;
      max-width: 36vw;
      max-height: 36vw;
      border-radius: 50%;
      border: 1.5px solid rgba(255,255,255,0.8);
      background: rgba(0,0,0,0.45);  /* 扁平，不再立体 */
      box-shadow: none;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      transition: border-color 140ms ease, background 140ms ease, transform 120ms ease;
      text-align: center;
      position: relative;
    }

    .spot:hover {
      border-color: rgba(255,255,255,1);
      background: rgba(255,255,255,0.05);
      transform: translateY(-2px);
    }

    /* 空状态时：小圆圈 + 中间一点 */
    .spot::before {
      content: "";
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
      opacity: 0.7;
      transition: opacity 120ms ease;
    }

    /* 有文字时取消中间小点 */
    .spot.has-text::before {
      opacity: 0;
    }

    .spot-text {
      font-size: 1.4rem;
      white-space: pre-wrap;
      word-break: break-word;
      max-width: 90%;
      line-height: 1.25;
      opacity: 0.95;
    }

    .spot-empty .spot-text {
      display: none; /* 只显示小点 */
    }

    .status-bar {
      position: absolute;
      bottom: 0.6rem;
      left: 0;
      right: 0;
      padding: 0 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1rem;
      opacity: 0.85;
      pointer-events: none;
      gap: 0.6rem;
    }

    .nav-hint {
      font-size: 0.95rem;
      opacity: 0.7;
    }

    .status-right {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    /* 编辑 overlay */
    .editor-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    .editor-overlay.visible {
      display: flex;
    }

    .editor-box {
      width: min(90%, 520px);
      background: #050505;
      padding: 1.2rem 1.6rem 1rem;
      border-radius: 1.2rem;
      border: 1px solid rgba(255,255,255,0.3);
      box-shadow: 0 0 32px rgba(0,0,0,0.9);
    }

    .editor-prompt {
      font-size: 1.4rem;
      margin-bottom: 0.6rem;
    }

    .editor-input {
      width: 100%;
      min-height: 90px;
      resize: vertical;
      background: #050505;
      border: 1px solid rgba(255,255,255,0.4);
      border-radius: 0.8rem;
      padding: 0.6rem 0.8rem;
      color: #fff;
      font-family: "Amatic SC", sans-serif;
      font-size: 1.4rem;
      outline: none;
    }

    .editor-input:focus {
      border-color: rgba(255,255,255,0.9);
    }

    .editor-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      margin-top: 0.8rem;
    }

    .btn {
      border: 1px solid rgba(255,255,255,0.7);
      background: transparent;
      padding: 0.4rem 1.4rem;
      border-radius: 999px;
      color: #fff;
      cursor: pointer;
      font-family: "Amatic SC", sans-serif;
      font-size: 1.2rem;
      transition: background 140ms ease, color 140ms ease, border-color 140ms ease;
      pointer-events: auto;
    }

    .btn:hover:not(:disabled) {
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.95);
      color: rgba(255,255,255,0.85);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    @media (max-width: 720px) {
      .spots-grid {
        grid-template-columns: 1fr;
        gap: 1.6rem;
        padding: 0 1.6rem;
      }
      .spot {
        width: 140px;
        height: 140px;
      }
      .scene-title {
        font-size: 1.1rem;
      }
      .status-bar {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>
  <main>
    <div class="scene-title">choose your memory</div>

    <div class="spots-layer">
      <div class="spots-grid">
        <div class="spot spot-empty" data-spot="1">
          <div class="spot-text"></div>
        </div>

        <div class="spot spot-empty" data-spot="2">
          <div class="spot-text"></div>
        </div>

        <div class="spot spot-empty" data-spot="3">
          <div class="spot-text"></div>
        </div>
      </div>
    </div>

    <div class="status-bar">
      <span id="entry-counter">your memory · click a circle to write</span>
      <div class="status-right">
        <span class="nav-hint">
          ← / → browse others · 0 = back to your circles
        </span>
        <!-- 新增：一次性保存三个 spot 的按钮 -->
        <button class="btn" id="save-all" disabled>save memory</button>
      </div>
    </div>
  </main>

  <!-- 编辑 overlay -->
  <div class="editor-overlay" id="editor-overlay">
    <div class="editor-box">
      <div class="editor-prompt" id="editor-prompt">
        who were you with last time you ate a burger?
      </div>
      <textarea id="editor-input" class="editor-input"></textarea>

      <div class="editor-buttons">
        <button class="btn" id="editor-cancel">cancel</button>
        <!-- 这里的按钮现在只是“确定这一格”，不再保存到 API -->
        <button class="btn" id="editor-save">ok</button>
      </div>
    </div>
  </div>

  <script>
    // ===== 状态 =====
    // currentIndex = -1 表示「自己的 circles（本地草稿）」；
    // >=0 表示正在看别人（API 中的某一条）
    let currentIndex = -1;
    let allEntries = [];
    let editingSpot = null;

    // 本地草稿：只属于当前用户，不依赖 API
    const draft = {
      spot1: "",
      spot2: "",
      spot3: ""
    };

    const prompts = {
      1: "who were you with last time you ate a burger?",
      2: "what were you eating?",
      3: "what could you hear around you?"
    };

    const spots = Array.from(document.querySelectorAll(".spot"));
    const entryCounter = document.getElementById("entry-counter");

    const overlay = document.getElementById("editor-overlay");
    const editorPrompt = document.getElementById("editor-prompt");
    const editorInput = document.getElementById("editor-input");
    const btnCancel = document.getElementById("editor-cancel");
    const btnSpotOk = document.getElementById("editor-save");

    const btnSaveAll = document.getElementById("save-all");

    // ===== 工具函数 =====

    function getCurrentEntry() {
      if (currentIndex < 0 || currentIndex >= allEntries.length) return null;
      return allEntries[currentIndex];
    }

    function allDraftFilled() {
      return (
        draft.spot1.trim().length > 0 &&
        draft.spot2.trim().length > 0 &&
        draft.spot3.trim().length > 0
      );
    }

    function renderDraft() {
      spots.forEach(spot => {
        const s = spot.dataset.spot;
        const key = "spot" + s;
        const value = (draft[key] || "").trim();
        const textEl = spot.querySelector(".spot-text");

        if (value) {
          spot.classList.remove("spot-empty");
          spot.classList.add("has-text");
          textEl.textContent = value;
        } else {
          spot.classList.add("spot-empty");
          spot.classList.remove("has-text");
          textEl.textContent = "";
        }
      });

      if (allEntries.length > 0) {
        entryCounter.textContent = `your memory · ${allEntries.length} others`;
      } else {
        entryCounter.textContent = "your memory · click a circle to write";
      }

      // 控制 “save memory” 按钮是否可点
      if (allDraftFilled()) {
        btnSaveAll.disabled = false;
      } else {
        btnSaveAll.disabled = true;
      }
    }

    function renderCurrentEntry() {
      if (currentIndex === -1) {
        renderDraft();
        return;
      }

      const entry = getCurrentEntry();
      if (!entry) {
        currentIndex = -1;
        renderDraft();
        return;
      }

      spots.forEach(spot => {
        const s = spot.dataset.spot;
        const key = "spot" + s;
        const value = (entry[key] || "").trim();
        const textEl = spot.querySelector(".spot-text");

        if (value) {
          spot.classList.remove("spot-empty");
          spot.classList.add("has-text");
          textEl.textContent = value;
        } else {
          spot.classList.add("spot-empty");
          spot.classList.remove("has-text");
          textEl.textContent = "";
        }
      });

      entryCounter.textContent =
        `memory ${currentIndex + 1} / ${allEntries.length} · read only`;

      // 看别人时，不能保存
      btnSaveAll.disabled = true;
    }

    async function loadAllEntriesFromAPI() {
      try {
        const resp = await fetch("/api/a-entries");
        if (!resp.ok) {
          console.error("load error HTTP", resp.status);
          return;
        }
        const data = await resp.json();
        if (Array.isArray(data)) {
          allEntries = data.sort(
            (a, b) => (a.createdAt || 0) - (b.createdAt || 0)
          );
        } else {
          allEntries = [];
        }
      } catch (err) {
        console.error("load entries error:", err);
      } finally {
        if (currentIndex === -1) {
          renderDraft();
        } else {
          renderCurrentEntry();
        }
      }
    }

    function openEditor(spotNumber) {
      editingSpot = spotNumber;
      const key = "spot" + spotNumber;

      editorPrompt.textContent = prompts[spotNumber] || "write something";
      editorInput.value = draft[key] || "";
      overlay.classList.add("visible");
      editorInput.focus();
      editorInput.select();
    }

    function closeEditor() {
      overlay.classList.remove("visible");
      editingSpot = null;
    }

    // 不再保存到 API，只更新本地 draft
    function confirmDraftSpot() {
      if (!editingSpot) return;
      const key = "spot" + editingSpot;
      draft[key] = editorInput.value.trim();
      closeEditor();
      // 仍然保持 currentIndex = -1（在自己的 memory 模式）
      currentIndex = -1;
      renderDraft();
    }

    // 真正发到 API 的保存：一次性提交 3 个 spot
    async function saveFullDraftToAPI() {
      if (!allDraftFilled()) return;

      const payload = {
        spot1: draft.spot1,
        spot2: draft.spot2,
        spot3: draft.spot3,
        createdAt: Date.now()
      };

      try {
        btnSaveAll.disabled = true;
        btnSaveAll.textContent = "saving...";

        const resp = await fetch("/api/a-entry", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          console.error("save error HTTP", resp.status);
        } else {
          console.log("saved entry");
        }
      } catch (err) {
        console.error("save error:", err);
      } finally {
        btnSaveAll.textContent = "save memory";
        // 保存完之后重新拉一次别人写的 memory
        await loadAllEntriesFromAPI();
        // 你可以选择是否清空自己的草稿，这里先保留
        currentIndex = -1;
        renderDraft();
      }
    }

    // ===== 事件 =====

    // 点击圆圈：只有在「自己的 memory 模式」下才能写
    spots.forEach(spot => {
      spot.addEventListener("click", () => {
        if (currentIndex !== -1) {
          // 正在看别人：只读
          return;
        }
        const n = Number(spot.dataset.spot);
        openEditor(n);
      });
    });

    btnCancel.addEventListener("click", (e) => {
      e.preventDefault();
      closeEditor();
    });

    // 现在这个按钮只是“OK”，不发网络请求
    btnSpotOk.addEventListener("click", (e) => {
      e.preventDefault();
      confirmDraftSpot();
    });

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        closeEditor();
      }
    });

    // 底部 “save memory” 按钮：一次性 POST 三个 spot
    btnSaveAll.addEventListener("click", async (e) => {
      e.preventDefault();
      if (!allDraftFilled()) return;
      await saveFullDraftToAPI();
    });

    // 键盘：左右键看别人；0 键回到自己的 circles；Esc 关编辑框
    document.addEventListener("keydown", (e) => {
      // 编辑框打开时只处理 Esc
      if (overlay.classList.contains("visible")) {
        if (e.key === "Escape") {
          e.preventDefault();
          closeEditor();
        }
        return;
      }

      const len = allEntries.length;
      if (len === 0) {
        // 没有别人可看
        if (currentIndex !== -1) {
          currentIndex = -1;
          renderDraft();
        }
        return;
      }

      if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
        // 把 [-1, 0..len-1] 映射到 0..len（循环）
        const total = len + 1; // 包含自己的 draft
        let pos = currentIndex + 1; // -1 -> 0, 0 -> 1, ...

        if (e.key === "ArrowRight") {
          pos = (pos + 1) % total;
        } else {
          pos = (pos - 1 + total) % total;
        }

        currentIndex = pos - 1; // 0 -> -1, 1 -> 0, ...
        if (currentIndex === -1) {
          renderDraft();
        } else {
          renderCurrentEntry();
        }
        e.preventDefault();
      } else if (e.key === "0") {
        // 快捷键：回到自己的 circles
        currentIndex = -1;
        renderDraft();
      }
    });

    // ===== 初始化 =====
    renderDraft();
    loadAllEntriesFromAPI();
  </script>
</body>
</html>